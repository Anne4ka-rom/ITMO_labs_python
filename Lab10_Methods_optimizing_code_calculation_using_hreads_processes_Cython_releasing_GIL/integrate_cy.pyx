import math # импортируем стандартный модуль math для математических функций
import cython # импортируем модуль cython для аннотаций и директив
from libc.math cimport cos as c_cos # импортируем C-функцию cos из стандартной библиотеки C
from cython.parallel import prange # импортируем prange для параллельных циклов в Cython


@cython.boundscheck(False) # отключаем проверку границ массивов для ускорения
@cython.wraparound(False) # отключаем проверку индексов с отрицательными значениями
def integrate_cy(f: callable, double a, double b, int n_iter=100000):
    '''
    Функция integrate_cy() является Cython-оптимизированной версией функции интегрирования
    методом прямоугольников
    
    Параметры:
    f -- Python-функция для интегрирования
    a -- нижний предел интегрирования
    b -- верхний предел интегрирования
    n_iter -- количество итераций
    
    Возвращает:
    double -- приближенное значение интеграла
    
    Вызывает:
    ValueError -- если n_iter <= 0 или b <= a
    '''
    if n_iter <= 0: # проверяем корректность количества итераций
        raise ValueError('n_iter должен быть положительным числом') # вызываем исключение
    if b <= a: # проверяем корректность пределов интегрирования
        raise ValueError('b должен быть больше a') # вызываем исключение
    
    cdef double acc = 0.0 # объявляем C-переменную acc типа double для накопления суммы
    cdef double step = (b - a) / n_iter # объявляем C-переменную step для шага интегрирования
    cdef double x # объявляем C-переменную x для текущей точки
    cdef int i # объявляем C-переменную i для счетчика цикла
    
    for i in range(n_iter): # выполняем цикл интегрирования
        x = a + i * step # вычисляем текущую точку x
        acc += f(x) * step # добавляем площадь прямоугольника, вызывая Python-функцию
    
    return acc # возвращаем результат интегрирования


@cython.boundscheck(False) # отключаем проверку границ массивов
@cython.wraparound(False) # отключаем проверку отрицательных индексов
def integrate_cos_cy(double a, double b, int n_iter=100000):
    '''
    Функция integrate_cos_cy() является специализированной версией для вычисления
    интеграла косинуса с максимальной оптимизацией
    
    Параметры:
    a -- нижний предел интегрирования
    b -- верхний предел интегрирования
    n_iter -- количество итераций
    
    Возвращает:
    double -- приближенное значение интеграла cos(x) на отрезке [a, b]
    '''
    cdef double acc = 0.0 # объявляем C-переменную acc типа double для накопления суммы
    cdef double step = (b - a) / n_iter # объявляем C-переменную step для шага интегрирования
    cdef double x # объявляем C-переменную x для текущей точки
    cdef int i # объявляем C-переменную i для счетчика цикла
    
    for i in range(n_iter): # выполняем цикл интегрирования
        x = a + i * step # вычисляем текущую точку x
        acc += math.cos(x) * step # используем функцию cos из модуля math
    
    return acc # возвращаем результат интегрирования


@cython.boundscheck(False) # отключаем проверку границ массивов
@cython.wraparound(False) # отключаем проверку отрицательных индексов
def integrate_cos_nogil(double a, double b, int n_iter=100000):
    '''
    Функция integrate_cos_nogil() является версией с отпусканием GIL
    для возможного параллельного выполнения
    
    Параметры:
    a -- нижний предел интегрирования
    b -- верхний предел интегрирования
    n_iter -- количество итераций
    
    Возвращает:
    double -- приближенное значение интеграла cos(x) на отрезке [a, b]
    '''
    cdef double acc = 0.0 # объявляем C-переменную acc типа double для накопления суммы
    cdef double step = (b - a) / n_iter # объявляем C-переменную step для шага интегрирования
    cdef double x # объявляем C-переменную x для текущей точки
    cdef int i # объявляем C-переменную i для счетчика цикла
    
    with nogil: # контекстный менеджер для выполнения кода без GIL
        for i in range(n_iter): # выполняем цикл интегрирования без GIL
            x = a + i * step # вычисляем текущую точку x
            acc += c_cos(x) * step # используем C-функцию cos вместо Python-функции
    
    return acc # возвращаем результат интегрирования


@cython.boundscheck(False) # отключаем проверку границ массивов
@cython.wraparound(False) # отключаем проверку отрицательных индексов
def integrate_cos_nogil_prange(double a, double b, int n_iter=100000, int n_threads=4):
    '''
    Функция integrate_cos_nogil_prange() является упрощенной многопоточной версией
    для демонстрации использования noGIL с параллельным выполнением
    
    Параметры:
    a -- нижний предел интегрирования
    b -- верхний предел интегрирования
    n_iter -- количество итераций
    n_threads -- количество потоков
    
    Возвращает:
    double -- приближенное значение интеграла cos(x) на отрезке [a, b]
    '''
    return integrate_cos_nogil(a, b, n_iter) # возвращаем результат однопоточной версии