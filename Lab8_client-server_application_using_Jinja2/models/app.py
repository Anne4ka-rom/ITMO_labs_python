class App:
    '''
    Класс App представляет приложение с названием, версией и автором
    Обеспечивает валидацию данных при установке свойств
    '''
    def __init__(self, name: str, version: str, author):
        '''
        Функция __init__() инициализирует новый экземпляр класса App
        
        Параметры:
        name -- название приложения
        version -- версия приложения
        author -- автор приложения

        Вызывает:
        TypeError -- если name или version не строки, или author не экземпляр Author
        ValueError -- если name или version пустые строки после удаления пробелов
        '''
        self._name = None # создаём защищённый атрибут для имени со значением None
        self._version = None # создаём защищённый атрибут для версии со значением None
        self._author = None # создаём защищённый атрибут для автора со значением None
        self.name = name # устанавливаем публичное свойство name через сеттер
        self.version = version # устанавливаем публичное свойство version через сеттер
        self.author = author # устанавливаем публичное свойство author через сеттер
    
    @property # декоратор для создания свойства
    def name(self) -> str:
        '''
        Функция name() возвращает название приложения в строковом виде
        '''
        return self._name # возвращаем значение защищённого атрибута _name
    
    @name.setter # декоратор, преобразующий метод name() в сеттер для свойства name
    def name(self, value: str):
        '''
        Функция name() устанавливает название приложения с валидацией
        
        Параметры:
        value -- новое название приложения
        
        Вызывает:
        TypeError -- если значение не является строкой
        ValueError -- если строка пустая после удаления пробелов
        '''
        if not isinstance(value, str): # проверяем, является ли значение чем-то кроме строки
            raise TypeError("Название приложения должно быть строкой") # вызываем исключение TypeError для неверного типа
        if len(value.strip()) == 0: # проверяем, пустая ли строка после удаления пробелов
            raise ValueError("Название приложения не может быть пустым") # вызываем исключение ValueError для пустой строки
        self._name = value.strip() # сохраняем очищенное значение в защищённый атрибут
    
    @property # декоратор для создания свойства
    def version(self) -> str:
        '''
        Функция version() возвращает версию приложения в строковом виде
        '''
        return self._version # возвращаем значение защищённого атрибута _version
    
    @version.setter # декоратор, преобразующий метод version() в сеттер для свойства version
    def version(self, value: str):
        '''
        Функция version() устанавливает версию приложения с валидацией
        
        Параметры:
        value -- новая версия приложения
        
        Вызывает:
        TypeError -- если значение не является строкой
        ValueError -- если строка пустая после удаления пробелов
        '''
        if not isinstance(value, str):  # проверяем, является ли значение чем-то кроме строки
            raise TypeError("Версия должна быть строкой") # вызываем исключение TypeError для неверного типа
        if len(value.strip()) == 0: # проверяем, пустая ли строка после удаления пробелов
            raise ValueError("Версия не может быть пустой") # вызываем исключение ValueError для пустой строки
        self._version = value.strip() # сохраняем очищенное значение в защищённый атрибут
    
    @property # декоратор для создания свойства
    def author(self):
        '''
        Функция author() возвращает автора приложения
        '''
        return self._author # возвращаем значение защищённого атрибута _author
    
    @author.setter # декоратор, преобразующий метод author() в сеттер для свойства author
    def author(self, value):
        '''
        Функция author() устанавливает автора приложения с валидацией
        
        Параметры:
        value -- автор приложения
        
        Вызывает:
        TypeError -- если значение не является экземпляром класса Author
        '''
        from .author import Author # импортируем класс Author из текущей папки
        if not isinstance(value, Author): # проверяем, является ли значение чем-то кроме экземпляра класса Author
            raise TypeError(f"Автор должен быть экземпляром класса Author, получено {type(value)}") # вызываем исключение TypeError для неверного типа
        self._author = value # сохраняем значение в защищённый атрибут
    
    def __repr__(self):
        '''
        Функция __repr__() возвращает строковое представление объекта для отладки
        '''
        return f"App(name='{self.name}', version='{self.version}', author={self.author})" # возвращаем форматированную строку с информацией об объекте