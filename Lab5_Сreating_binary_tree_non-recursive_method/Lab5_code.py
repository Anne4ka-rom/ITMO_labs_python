from collections import deque as dq # импортируем двустороннюю очередь (deque) из библиотеки collections и даём её короткое имя -- dq
'''Двусторонняя очередь (deque) -- позволяет добавлять элемент и в начало очереди, и в конец, 
а также удалять/брать элемент из начала или конца очереди'''


def gen_bin_tree(height: int, root: int, left_branch = lambda l_b: l_b ** 2, right_branch = lambda r_b: 2 + r_b ** 2):
    '''Функция get_bin_tree получает на вход ключевые аргументы и с их помощью строит бинарное дерево 
    с заданным корнем, высотой и функциями для двух ветвей НЕ рекурсивным методом
    
    Ключевые аргументы:
    height -- высота дарева (количество вершин на одной ветви)
    root -- корень дерева (число, к которому будем применять функции построения вершин ветвей)
    left_branch -- функция для левой ветви дерева
    right_branch -- функция для правой ветви дерева'''
    
    result = {root: []} # создаём словарь result, в котором будут отображаться наши вершины и ветви, исходящии из них -- дерево

    if isinstance(height, int) and isinstance(root, int) and height >= 0: # проверяем: если высота height и корень root -- целые числа и высота height больше или равна 0
        if height == 0: # првоеряем: если высота -- 0
            return result # возвращаем результат из переменной result (0-ая вершина -- корень дерева)
        
        queue = dq([(root, 0, result[root])]) # создаём двойную очередь -- queue и задаём ей список из одного элемента -- кортежа: root -- текущее значение вершины, 0 -- уровень текущей высоты вершины (изначально у нас корень дерева, поэтому значение -- 0), result[root] -- список ветвей для текущей вершины
        
        while queue: # проверяем: пока условие, что в очереди queue есть хоть один элемент, верно
            value, height_value, branches_list = queue.popleft() # берём левый элемент очереди queue (кортеж из 3-ёх элементов) и присваеваем 3 значения кортежа переменным: value -- текущее значение вершины, height_value -- уровень текущей высоты вершины, branches_list -- список ветвей для текущей вершины
            
            if height_value < height: # проверяем: если текущая высота вершины строго меньше высоты дерева
                left_value = left_branch(value) # задаём вершину левой ветви -- left_value путём передачи функции left_branch значения текущей вершины value
                right_value = right_branch(value) # задаём вершину правой ветви -- right_value путём передачи функции right_branch значения текущей вершины value
                
                left_vertex = {left_value: []} # задаём ветвь левой вершины left_vertex путём создания словаря: left_value -- вершина левой ветви, которому принадлежит пустой список [] (будущие ветви)
                right_vertex = {right_value: []} # задаём ветвь правой вершины right_vertex путём создания словаря: right_vertex -- вершина правой ветви, которому принадлежит пустой список [] (будущие ветви)
                
                branches_list.extend([left_vertex, right_vertex]) # добавляем в список ветвей 2-а элемента(!): left_vertex -- левую вевь дерева и right_vertex -- правую ветвь дерева
                '''метод extend -- добавляет все элементы итерируемого объекта в конец списка
                
                Отличие от append: append добавляет объект, extend добавляет элементы'''

                queue.append((left_value, height_value + 1, left_vertex[left_value])) # добавляем в очередь queue кортеж элементов: left_value -- вершина левой ветви, height_value + 1 -- увеличиваем текущее значение высоты на 1, left_vertex[left_value] -- список ветвей для левой вершины
                queue.append((right_value, height_value + 1, right_vertex[right_value])) # добавляем в очередь queue кортеж элементов: right_value -- вершина правой ветви, height_value + 1 -- увеличиваем текущее значение высоты на 1, right_vertex[right_value] -- список ветвей для правой вершины
    
        return result # возвращаем результат result
    return None # в противно случае возвращаем None


print(gen_bin_tree(3, 11)) # печатаем дерево с заданными параметрами
