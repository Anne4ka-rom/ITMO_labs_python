import logging # импортируем logging для записи информации о работе программы
import math # импортируем модуль math для вычисления квадратного корня
from typing import Optional, Tuple # импортируем типы данных для аннотаций


# настраиваем базовую конфигурацию логирования: имя файла для записи логов, минимальный уровень логирования, формат записи: "уровень: сообщение"
logging.basicConfig(
    filename="quadratic.log",
    level=logging.DEBUG,
    format="%(levelname)s: %(message)s"
)

def solve_quadratic(a: float, b: float, c: float) -> Optional[Tuple[float, ...]]:
    '''
    Функция solve_quadratic() решает квадратное уравнение ax^2 + bx + c = 0 с полным логированием
    
    Параметры:
    a -- коэффициент при x^2
    b -- коэффициент при x
    c -- свободный член
    
    Возвращает:
    None -- если нет действительных корней (D < 0)
    Tuple[float] -- один корень если D = 0 или a = 0
    Tuple[float, float] -- два корня если D > 0
    
    Исключения:
    ValueError -- a=0 и b=0 (уравнение не имеет смысла)
    TypeError -- некорректный тип коэффициентов
    '''

    logging.info(f"Вызов функции с параметрами: a={a}, b={b}, c={c}") # логируем начало работы функции с переданными параметрами

    for name, value in zip(("a", "b", "c"), (a, b, c)): # проходим по всем трем коэффициентам для проверки их типов
        if not isinstance(value, (int, float)): # проверяем, если хотя бы один коэффициент не является числом типа int или типа float
            logging.error(f"Коэффициент '{name}'='{value}' имеет неверный тип {type(value).__name__}") # логируем ошибку с информацией о некорректном типе
            raise TypeError(f"Коэффициент '{name}' должен быть числом, получено: {type(value)}") # вызываем исключение TypeError

    if a == 0: # проверяем, равен ли коэффициент a нулю
        if b == 0: # проверяем, равен ли коэффициент b нулю
            logging.critical("Оба коэффициента a и b равны нулю") # логируем критическую ошибку
            raise ValueError("Оба коэффициента a и b равны нулю") # вызываем исключение ValueError

        logging.info(f"Линейное уравнение: {b}x + {c} = 0") # логируем информацию о решении линейного уравнения
        x = -c / b # вычисляем корень линейного уравнения
        logging.info(f"Найден корень линейного уравнения: x = {x}") # логируем найденный корень
        return (x,) # возвращаем кортеж с одним корнем

    logging.info(f"Квадратное уравнение: {a}x^2 + {b}x + {c} = 0") # логируем информацию об уравнении
    
    d = b*b - 4*a*c # вычисляем дискриминант
    logging.debug(f"Дискриминант D = {b}^2 - 4*{a}*{c} = {d}") # логируем отладочную информацию с деталями вычислений (уровень DEBUG)

    if d < 0: # проверяем, является ли дискриминант отрицательным
        logging.warning(f"Дискриминант отрицательный (D={d}). Действительных корней нет") # логируем предупреждение (уровень WARNING)
        return None # возвращаем None (отсутствия корней)

    if d == 0: # проверяем, равен ли дискриминант нулю
        x = -b / (2*a) # вычисляем корень
        logging.info(f"Дискриминант равен нулю. Один корень: x = {x}") # логируем информацию о найденном корне
        return (x,) # возвращаем кортеж с одним корнем

    sqrt_d = math.sqrt(d) # вычисляем квадратный корень из дискриминанта
    x1 = (-b + sqrt_d) / (2*a) # вычисляем первый корень
    x2 = (-b - sqrt_d) / (2*a) # вычисляем второй корень
    logging.info(f"Найдено два корня: x1 = {x1:.2f}, x2 = {x2:.2f}") # логируем информацию о двух корнях с округлением до 2ух знаков после запятой
    return (x1, x2) # возвращаем кортеж с двумя корнями

if __name__ == "__main__":
    result = solve_quadratic(1, 6.2, 8) # вызываем функцию для нахождения корней квадратного уравнения
    print(f"Корни: {result}") # выводим полученные корни уравнения