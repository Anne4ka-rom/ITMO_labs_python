def main():
    '''Получение данных с клавиатуры'''
    target = input('Введи число, которое нужно отгадать: ') # загаданное пользователем число
    t_or_f = input('Вы хотите задать список с клавиатуры (yes/no): ') # пользователь выбирает, как задать диапазон
    if t_or_f == 'yes': # проверяем, хочет пользователь ввести список целиком или только обозначить границы диапазон
        nums = list(map(int, input('Введи список, в котором программа будет искать число (целые числа через пробел): ').split())) # ввод списка пользователем
    elif t_or_f == 'no':
        borders = list(map(int, input('Введи верхнюю и нижнюю границы (целые числа через пробел): ').split())) # ввод пользователем верхней и нижней границы
        nums = list(range(min(borders), max(borders) + 1)) # создание диапазона
    else:
        nums = [] # создание пустого списка, чтобы запустить функцию guess_func, если пользователь не ввёл yes или no
    type = input('Выберите алгоритм для поиска числа (bin/seq): ') # пользователь задаёт тип алгоритма поиска

    return guess_func(target=target, nums=nums, type=type) # вызов функции угадывания числа

def senquential(target: int, nums: list[int], count=0):
    '''Реализация алгоритма бинарного поиска.

    Ключевые аргументы:
    target -- число, которое нужно угадать
    nums -- список целых чисел, в которм ищем target
    count -- количество угадываний
    '''
    for num in nums: # циклом for пробегаемся по элементам списка
        if num != target: # если число не равно загаданному числу
            count += 1 # увеличиваем количество угадывания на 1
        else:
            count += 1 # увеличиваем количество угадывания на 1, т.к. мы не подсчитывали первое угадывание
            return [num, count] # возвращаем загаданное число и количество угадываний
    return None # если цикл вылетел или не запустился возвращаем None
        
def binary(target: int, nums: list[int], count=0):
    '''Реализация алгоритма медленного перебора.
    
    Ключевые аргументы:
    target -- число, которое нужно угадать
    nums -- список целых чисел, в которм ищем target
    count -- количество угадываний
    '''
    while len(nums) > 0: # пока в списке есть хоть один элемент
        mid = len(nums) // 2 # ищем середину списка
        num = nums[mid] # присваеваем переменной num число из списка nums с индексом mid
        if num != target: # если num не является target-ом
            if target > num: # проверяем больше ли target, чем num
                nums = nums[mid + 1:] # если да, оставляем часть списка начиная с элемента с индексом mid + 1, т.к. mid мы уже проверили
            else:
                nums = nums[:mid] # если нет, оставляем части списка с самого начала до элемента с индексом mid(не включая его)
            count += 1 # увеличиваем количество угадывания на 1
        else:
            count += 1 # увеличиваем количество угадывания на 1, т.к. мы не подсчитывали первое угадывание
            return [num, count] # возвращаем загаданное число и количество угадываний
    return None # если цикл вылетел или не запустился возвращаем None


def guess_func(target: int, nums: list[int], type: str):
    '''Поиск загаданного числа с помощью одного из двух алгоритмов.
    
    Ключевые аргументы:
    target -- число, которое нужно угадать
    nums -- список целых чисел, в которм ищем target
    type -- тип алгоритма, который будет искать загаданное число
    '''
    if str(target).lstrip('-+').isdigit() and all([isinstance(num, int) for num in nums]) and isinstance(type, str) \
        and (type == 'bin' or type == 'seq'): # проверяем, что target - целое число, в списке nums  лежать целые числа, type  является строкой и содержит в себе либо bin, либо seq
        target = int(target) #  т.к. target был задан строкой, во избежании ошибки при не ккоректном вводе, меняем его тип на int 
        nums.sort() # сортируем список nums по возрастанию
        if type == 'seq': # если type содержит в себе seq
            result = senquential(target=target, nums=nums) # записываем в result результат выполнения функции senquential
            return result # возвращаем результат
        elif type == 'bin': # если type содержит в себе bin
            result = binary(target=target, nums=nums) # записываем в result результат выполнения функции binary
            return result # возвращаем результат
        return None # если ни одно из представленных выше условий не верно, возвращвем None 
    return None # если какое-то из условий if-а нарушено, возвращаем None


if __name__ == '__main__': # запуск функции main
    result = main() # присваиваем результат выполнения функции main переменной result
    print('-' * 100) # делвем красивое пунктирное разгрничения входных и выходных данных
    print(result) # выводим на печать значение переменной result